import folium
import pandas as pd
import streamlit as st
from folium.plugins import Draw
from streamlit_folium import st_folium
import numpy as np
from PIL import Image
import leafmap.foliumap as foliumap
from scripts.existing_resources import *
import altair as alt
from statsmodels.tsa.holtwinters import ExponentialSmoothing

st.set_page_config(page_title="Streamlit Geospatial", layout="wide")
### DATA
data = pd.read_csv('data/Power_Plants.csv')
resources = ['Hydroelectric', 'Solar', 'Wind']
data = data[data['PrimSource'].isin(resources)]
###


# Import historical renewable energy data and make dataframe
historical_gen_billion_Btu = pd.read_csv('data/historical_renewable_energy_production_by_state_in_billion_Btu.csv')
# Imoport total energy production by state (including renewables and fossil fuels)
historical_total_billion_Btu = pd.read_csv('data/historical_total_energy_production_by_state_in_billion_Btu.csv')
# convert all columns (except year) from billion Btu to GWh
historical_gen = historical_gen_billion_Btu.drop('year', axis = 1) * (1.0/3.412)
historical_total = historical_total_billion_Btu.drop('year', axis = 1) * (1.0/3.412)

# Calclate fraction of energy generated by renewables and put it in a new dataframe.
renewable_energy_fraction = pd.DataFrame() # new dataframe
for state_name in list(historical_gen):
    renewable_energy_fraction[state_name] = 100.0 * historical_gen[state_name]/historical_total[state_name]

# Add back the year column
historical_gen['year'] = historical_gen_billion_Btu['year'] # Now we can start plotting.
historical_total['year'] = historical_total_billion_Btu['year']
renewable_energy_fraction['year'] = historical_total_billion_Btu['year']

# Function that uses double exponential smoothing to predict renewable energy production and % energy from renewables up to the year 2050.
def smooth2(x_future, y_data): # takes "array-like" data let's try a pandas series.
    # create model
    ex_smooth_model = ExponentialSmoothing(y_data, trend = 'additive', damped = True)
    # fit model
    ex_fit = ex_smooth_model.fit()
    # make prediction
    yhat = ex_fit.predict(start = len(y_data), end = len(y_data)+len(x_future) - 1) # predict y values for future years
    return yhat


original_title = '<h1 style=color:green>The Green Solution</h1>'
st.markdown(original_title, unsafe_allow_html=True)

col1, col2, col3 = st.columns(3)
with col1:
    st.write("Wind")
    image = Image.open("images/wind.JPG")
    st.image(image)
with col2:
    st.write("Hydro")
    image = Image.open("images/hydro.JPG")
    st.image(image)
with col3:
    st.write("Solar")
    image = Image.open("images/solar.JPG")
    st.image(image)

countries = ['USA']
states = ['AK', 'AL', 'AR', 'AZ', 'CA', 'CO', 'CT', 'DC', 'DE', 'FL', 'GA',
          'HI', 'IA', 'ID', 'IL', 'IN', 'KS', 'KY', 'LA', 'MA', 'MD', 'ME',
          'MI', 'MN', 'MO', 'MS', 'MT', 'NC', 'ND', 'NE', 'NH', 'NJ', 'NM',
          'NV', 'NY', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC', 'SD', 'TN', 'TX',
          'UT', 'VA', 'VT', 'WA', 'WI', 'WV', 'WY']
states = {
    'AK': 'Alaska',
    'AL': 'Alabama',
    'AR': 'Arkansas',
    'AZ': 'Arizona',
    'CA': 'California',
    'CO': 'Colorado',
    'CT': 'Connecticut',
    'DC': 'District of Columbia',
    'DE': 'Delaware',
    'FL': 'Florida',
    'GA': 'Georgia',
    'HI': 'Hawaii',
    'IA': 'Iowa',
    'ID': 'Idaho',
    'IL': 'Illinois',
    'IN': 'Indiana',
    'KS': 'Kansas',
    'KY': 'Kentucky',
    'LA': 'Louisiana',
    'MA': 'Massachusetts',
    'MD': 'Maryland',
    'ME': 'Maine',
    'MI': 'Michigan',
    'MN': 'Minnesota',
    'MO': 'Missouri',
    'MS': 'Mississippi',
    'MT': 'Montana',
    'NC': 'North Carolina',
    'ND': 'North Dakota',
    'NE': 'Nebraska',
    'NH': 'New Hampshire',
    'NJ': 'New Jersey',
    'NM': 'New Mexico',
    'NV': 'Nevada',
    'NY': 'New York',
    'OH': 'Ohio',
    'OK': 'Oklahoma',
    'OR': 'Oregon',
    'PA': 'Pennsylvania',
    'RI': 'Rhode Island',
    'SC': 'South Carolina',
    'SD': 'South Dakota',
    'TN': 'Tennessee',
    'TX': 'Texas',
    'UT': 'Utah',
    'VA': 'Virginia',
    'VT': 'Vermont',
    'WA': 'Washington',
    'WI': 'Wisconsin',
    'WV': 'West Virginia',
    'WY': 'Wyoming'
}

statesBounding = {'AL': [-88.473227, 30.223334, -84.88908, 35.008028],
                  'AK': [-179.148909, 51.214183, 179.77847, 71.365162],
                  'AZ': [-114.81651, 31.332177, -109.045223, 37.00426],
                  'AR': [-94.617919, 33.004106, -89.644395, 36.4996],
                  'CA': [-124.409591, 32.534156, -114.131211, 42.009518],
                  'CO': [-109.060253, 36.992426, -102.041524, 41.003444],
                  'CT': [-73.727775, 40.980144, -71.786994, 42.050587],
                  'DE': [-75.788658, 38.451013, -75.048939, 39.839007],
                  'FL': [-87.634938, 24.523096, -80.031362, 31.000888],
                  'GA': [-85.605165, 30.357851, -80.839729, 35.000659],
                  'HI': [-178.334698, 18.910361, -154.806773, 28.402123],
                  'ID': [-117.243027, 41.988057, -111.043564, 49.001146],
                  'IL': [-91.513079, 36.970298, -87.494756, 42.508481],
                  'IN': [-88.09776, 37.771742, -84.784579, 41.760592],
                  'IA': [-96.639704, 40.375501, -90.140061, 43.501196],
                  'KS': [-102.051744, 36.993016, -94.588413, 40.003162],
                  'KY': [-89.571509, 36.497129, -81.964971, 39.147458],
                  'LA': [-94.043147, 28.928609, -88.817017, 33.019457],
                  'ME': [-71.083924, 42.977764, -66.949895, 47.459686],
                  'MD': [-79.487651, 37.911717, -75.048939, 39.723043],
                  'MA': [-73.508142, 41.237964, -69.928393, 42.886589],
                  'MI': [-90.418136, 41.696118, -82.413474, 48.2388],
                  'MN': [-97.239209, 43.499356, -89.491739, 49.384358],
                  'MS': [-91.655009, 30.173943, -88.097888, 34.996052],
                  'MO': [-95.774704, 35.995683, -89.098843, 40.61364],
                  'MT': [-116.050003, 44.358221, -104.039138, 49.00139],
                  'NE': [-104.053514, 39.999998, -95.30829, 43.001708],
                  'NV': [-120.005746, 35.001857, -114.039648, 42.002207],
                  'NH': [-72.557247, 42.69699, -70.610621, 45.305476],
                  'NJ': [-75.559614, 38.928519, -73.893979, 41.357423],
                  'NM': [-109.050173, 31.332301, -103.001964, 37.000232],
                  'NY': [-79.762152, 40.496103, -71.856214, 45.01585],
                  'NC': [-84.321869, 33.842316, -75.460621, 36.588117],
                  'ND': [-104.0489, 45.935054, -96.554507, 49.000574],
                  'OH': [-84.820159, 38.403202, -80.518693, 41.977523],
                  'OK': [-103.002565, 33.615833, -94.430662, 37.002206],
                  'OR': [-124.566244, 41.991794, -116.463504, 46.292035],
                  'PA': [-80.519891, 39.7198, -74.689516, 42.26986],
                  'RI': [-71.862772, 41.146339, -71.12057, 42.018798],
                  'SC': [-83.35391, 32.0346, -78.54203, 35.215402],
                  'SD': [-104.057698, 42.479635, -96.436589, 45.94545],
                  'TN': [-90.310298, 34.982972, -81.6469, 36.678118],
                  'TX': [-106.645646, 25.837377, -93.508292, 36.500704],
                  'UT': [-114.052962, 36.997968, -109.041058, 42.001567],
                  'VT': [-73.43774, 42.726853, -71.464555, 45.016659],
                  'VA': [-83.675395, 36.540738, -75.242266, 39.466012],
                  'WA': [-124.763068, 45.543541, -116.915989, 49.002494],
                  'WV': [-82.644739, 37.201483, -77.719519, 40.638801],
                  'WI': [-92.888114, 42.491983, -86.805415, 47.080621],
                  'WY': [-111.056888, 40.994746, -104.05216, 45.005904]}

# Construct a dictionary of calculated wind and solar potential for each state:
state_potential_dict = {}
for my_state in states.keys(): # Make dictionary of wind and solar potential values for each state. In the final version these will be calculated in a function from geodata.
    state_potential_dict[my_state] = {'wind_potential': max(historical_gen[my_state]) * 2, 'solar_potential': max(historical_gen[my_state]) * 3}


energytype = ['Wind', 'Solar', 'Hydroelectric']
state_groups = data.groupby(['StateName', 'PrimSource'])
state_dict = {}
for (state, res_type), group in state_groups:
    if state not in state_dict:
        state_dict[state] = {}
    state_dict[state][res_type] = group[['Latitude', 'Longitude']].values.tolist()
wind, water, solar = resource_locations(data)


with st.sidebar.container():
    st.markdown(
        f"""
        # Getting Started 
        1. Click the black polygon on the map
        2. Select the desired locations to analyze various renewable energy options
        3. Optional: Apply customizations
        """,
        unsafe_allow_html=True,
    )

    st.selectbox("Country", countries, help="Only the United States is currently supported")
    state = st.selectbox("Find Renewable Energy Near You", states, help="Select a state to zoom in on", index=0)
    energy_type = st.selectbox("Renewable Energy Type", energytype,
                               help="Select an energy type you would like displayed")
    show = st.checkbox('Show me the data!')

col1, col2 = st.columns([3, 1])
with col1:
    m = foliumap.Map(
        location=[40.580585, -95.779294],
        zoom_start=4,
        control_scale=False,
        attr='Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
    )
    Draw(
        export=False,
        position="topleft",
        draw_options={
            "polyline": False,
            "poly": False,
            "circle": False,
            "polygon": True,
            "marker": False,
            "circlemarker": False,
            "rectangle": False,
        },
    ).add_to(m)
    if state != 'AK':
        m.zoom_to_bounds(statesBounding[state])
    folium.TileLayer('openstreetmap').add_to(m)


    if show:
        if state == 'AK':
            for coord in wind:
                folium.CircleMarker([coord[0], coord[1]], radius=4, color ='#8d99ae', fill_color="#8d99ae").add_to(m)
            for coord in solar:
                folium.CircleMarker([coord[0], coord[1]], radius=4, color ='#ffd166', fill_color="#ffd166").add_to(m)
            for coord in water:
                folium.CircleMarker([coord[0], coord[1]], radius=4, color ='#118ab2', fill_color="#118ab2").add_to(m)

        else:
            if energy_type in state_dict[states[state]]:
                for coord in state_dict[states[state]][energy_type]:
                    if energy_type == "Wind":
                        folium.CircleMarker([coord[0], coord[1]], radius=8, color ='#8d99ae', fill_color="#8d99ae").add_to(m)
                    elif energy_type == "Solar":
                        folium.CircleMarker([coord[0], coord[1]], radius=8, color='#ffd166', fill_color="#ffd166").add_to(m)
                    else:
                        folium.CircleMarker([coord[0], coord[1]], radius=8, color='#118ab2', fill_color="#118ab2").add_to(m)

    output = st_folium(m, key="init", width=1000, height=600)

    labels = ['Wind', 'Solar', 'Hydroelectric']
    colors = ['#8d99ae', '#ffd166', '#118ab2']

    m.add_legend(title='Legend', labels=labels, colors=colors)

with col2:
    # chart_data = pd.DataFrame(
    #     {'Resource Type': ["Solar", "Wind", "Hydro"],
    #      'pistachio': [10,50,78],
    #      'kw/year': np.random.randint(130, size=3)})
    # st.write(state + " Power Production From Renewables")
    # st.line_chart(historical_gen, x = 'year', y = state)
    # st.write(state)
    # st.write(state_potential_dict[state])
    # Make altair chart that is more customizable then default line_chart
    # append columns to historical_gen
    # define color scale:
    # scale = alt.Scale(domain=['historical_gen', 'solar_potential', 'wind_potential'], range=['blue', 'red', 'green'])
    historical_gen_chart = (
            alt.Chart(
                data=historical_gen,
                title= state + " Power Produced From Renewables ",
            )
            .mark_line()
            .encode(
                # x=alt.X("capacity 1", axis=alt.Axis(title="Capacity 1")),
                # x=alt.X("capacity 2", axis=alt.Axis(title="Capacity 2")),
                x=alt.X('year', title='year'),
                y=alt.Y(state, title='GWh'),
                #color = alt.Color('blue')
            )
            #.mark_rule(color='red').encode(y=alt.datum(1))
            #.mark_rule(color='red').encode(y=alt.datum(state_potential_dict[state]['solar_potential']))
    )

    # make new data frame for predicted renewable generation from 2020 to 2050
    future_years = list(range(2020,2051))
    hgf_df = pd.DataFrame({ 
    'year': future_years,
    'Predicted Renewable Generation': smooth2(future_years, historical_gen[state]) })

    hgf_chart = (  # historical generation fit chart
        alt.Chart(hgf_df).mark_line(color = 'blue', strokeDash=[2, 6], size=2).encode(
        x = 'year',
        y = 'Predicted Renewable Generation',
        )
    )

    sp_df = pd.DataFrame({
    'Solar Potential': [state_potential_dict[state]['solar_potential']]*len(list(range(1960,2051))),
    'year': list(range(1960,2051)) })

    #  solar_potential_line = alt.Chart(sp_df).mark_line(color= 'red').encode(
    solar_potential_line = alt.Chart(sp_df).mark_line(color = 'red', strokeDash=[12, 6], size=2).encode(
    x= 'year',
    y= 'Solar Potential',
    #color = alt.Color('red')
    # .mark_text(text='doubles every 2 days', angle=0)
    ) 

    # # This needs to correspond to a df with only 1 coordinate, not sp_df
    # solar_potential_text = alt.Chart(sp_df).mark_text(text= state + ' Maximum Solar Potential', color = 'red', angle=0).encode(
    # x= 'year',
    # y= 'Solar Potential',
    # #color = alt.Color('red')
    # # .mark_text(text='doubles every 2 days', angle=0)
    # ) 

    
    wp_df = pd.DataFrame({
        'Wind Potential': [state_potential_dict[state]['wind_potential']]*len(list(range(1960,2051))),
        'year': list(range(1960,2051)) })

    wind_potential_line = alt.Chart(wp_df).mark_line(color = 'green', strokeDash=[12, 6], size=2).encode(
    x= 'year',
    y= 'Wind Potential',
    )   
    st.altair_chart(historical_gen_chart + hgf_chart + solar_potential_line + wind_potential_line)

    # st.altair_chart(historical_gen_chart + hgf_chart + solar_potential_line + solar_potential_text + wind_potential_line)
   
    # Now try to make a second chart here:

        # chart_data = pd.DataFrame(
        #     {'Resource Type': ["Solar", "Wind", "Hydro"], 'LCOE': np.random.randint(130, size=3)})
        # st.write("Levelized Cost of Energy (lifetime cost/lifetime output")
        # st.bar_chart(chart_data, x='Resource Type', y='LCOE')

    renewable_fraction_chart = (
                alt.Chart(
                    data=renewable_energy_fraction,
                    title= state + " % Power Produced From Renewables",
                )
                .mark_line()
                .encode(
                    x=alt.X('year', title='year'),
                    y=alt.Y(state, title=' % Power Produced From Renewables'),
                    #color = alt.Color('blue')
                )
                #.mark_rule(color='red').encode(y=alt.datum(1))
                #.mark_rule(color='red').encode(y=alt.datum(state_potential_dict[state]['solar_potential']))
        )
    # make new data frame for predicted renewable generation from 2020 to 2050
    pred_percent_df = pd.DataFrame({ 
    'year': future_years,
    'Predicted Percent Power From Renewables': smooth2(future_years, renewable_energy_fraction[state]) })

    pred_percent_chart = (  # historical generation fit chart
        alt.Chart(pred_percent_df).mark_line(color = 'blue', strokeDash=[2, 6], size=2).encode(
        x = 'year',
        y = 'Predicted Percent Power From Renewables',
        )
    )
    st.altair_chart(renewable_fraction_chart + pred_percent_chart)


col1, col2, col3, col4 = st.columns(4)
with col1:
    st.markdown("## Best Resource")
    st.markdown("- Solar")

with col2:
    st.markdown("## Best Investment")
    st.markdown("- Wind")

with col3:
    st.markdown(f"## Incentives for solar in {state}:")

with col4:
    st.markdown(f"## Incentives for solar in {state}:")

# https://stackoverflow.com/questions/69409255/how-to-get-city-state-and-country-from-a-list-of-latitude-and-longitude-coordi#
